using Newtonsoft.Json;

namespace Glitch9.AIDevKit.OpenAI.Realtime
{
    /// <summary>
    /// A realtime Item is of three types: message, function_call, or function_call_output.
    /// <para>A message item can contain text or audio.</para>
    /// <para>A function_call item indicates a model's desire to call a tool.</para>
    /// <para>A function_call_output item indicates a function response.</para>
    /// <para>The client may add and remove message and function_call_output Items using conversation.item.create and conversation.item.delete.</para>
    /// </summary>
    public class RealtimeItem
    {
        /// <summary>
        /// The unique ID of the item.
        /// </summary>
        [JsonProperty("id")] public string Id { get; set; }

        /// <summary>
        /// The object type.
        /// </summary>
        [JsonProperty("object")] public string Object { get; set; }

        /// <summary>
        /// The type of the item.
        /// </summary>
        [JsonProperty("type")] public RealtimeItemType Type { get; set; }

        /// <summary>
        /// The status of the item.
        /// </summary>
        [JsonProperty("status")] public RealtimeItemStatus? Status { get; set; }

        /// <summary>
        /// Additional details about the status.
        /// </summary>
        [JsonProperty("status_details")] public RealtimeItemStatusDetails StatusDetails { get; set; }

        /// <summary>
        /// The role associated with the item.
        /// </summary>
        [JsonProperty("role")] public ChatRole? Role { get; set; }

        /// <summary>
        /// The content of the item.
        /// </summary>
        [JsonProperty("content")] public RealtimeItemContent[] Content { get; set; }

        /// <summary>
        /// The ID of the function call (for "function_call" items).
        /// </summary>
        [JsonProperty("call_id")] public string CallId { get; set; }

        /// <summary>
        /// The name of the function being called (for "function_call" items).
        /// </summary>
        [JsonProperty("name")] public string Name { get; set; }

        /// <summary>
        /// The arguments of the function call (for "function_call" items).
        /// </summary>
        [JsonProperty("arguments")] public string Arguments { get; set; }

        /// <summary>
        /// The list of output items generated by the response.
        /// </summary>
        [JsonProperty("output")] public RealtimeItem[] Output { get; set; }

        /// <summary>
        /// Usage statistics for the response.
        /// </summary>
        [JsonProperty("usage")] public Usage Usage { get; set; }

        public static RealtimeItem UserMessage(string text)
        {
            return new RealtimeItem
            {
                Type = RealtimeItemType.Message,
                Role = AIDevKit.ChatRole.User,
                Content = new[] { RealtimeItemContent.CreateInputText(text) }
            };
        }

        public static RealtimeItem UserAudio(string base64EncodedAudio)
        {
            return new RealtimeItem
            {
                Type = RealtimeItemType.Message,
                Role = AIDevKit.ChatRole.User,
                Content = new[] { RealtimeItemContent.CreateInputAudio(base64EncodedAudio, null) }
            };
        }

        public string ToStatusString()
        {
            return Status?.ToString() ?? "Unknown";
        }

        public string GetTranscript()
        {
            if (Content == null || Content.Length == 0) return string.Empty;
            foreach (var item in Content)
            {
                if (item.Type == RealtimeItemContentType.InputAudio && !string.IsNullOrEmpty(item.Transcript))
                {
                    return item.Transcript;
                }
            }

            return string.Empty;
        }

        public string GetOutputText()
        {
            if (Content == null || Content.Length == 0) return string.Empty;
            foreach (var item in Content)
            {
                if (item.Type == RealtimeItemContentType.Text && !string.IsNullOrEmpty(item.Text))
                {
                    return item.Text;
                }
            }

            return string.Empty;
        }
    }
}
