using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using Glitch9.AIDevKit.GENTasks;
using Glitch9.CoreLib.IO.Audio;
using Glitch9.IO.Files;
using Newtonsoft.Json;
using UnityEngine;

namespace Glitch9.AIDevKit
{
    public interface IGENTask
    {
#pragma warning disable IDE1006
        Model model { get; }
        string sender { get; }
        int n { get; }
        string outputPath { get; }
        string fileNote { get; }
        bool saveOutput { get; }
        bool ignoreLogs { get; }
        bool enableHistory { get; }
        Dictionary<string, object> options { get; }
        MIMEType outputMimeType { get; }
        bool isWrapperTask { get; }
#pragma warning restore IDE1006
        void SetOption(string key, object value);
        bool TryGetOption<T>(string key, out T value);
        UniTask<T> ExecuteAsync<T>();
    }

    /// <summary>
    /// Abstract base class for all generative AI tasks (text, image, audio).
    /// Supports text, image, and audio prompts with fluent configuration methods.
    /// </summary>
    public abstract class GENTask<TSelf, TPrompt, TResult> : IGENTask
        where TSelf : GENTask<TSelf, TPrompt, TResult>
        where TResult : IGeneratedResult
    {
        // public static implicit operator UniTask<TResult>(GENTask<TSelf, TResult> task) => task.ExecuteAsync();
        // public UniTask<TResult>.Awaiter GetAwaiter() => ExecuteAsync().GetAwaiter();

        // Task State Management --------------------------------------------------------------------------------------------------  
        private CancellationTokenSource _cts = new();

#pragma warning disable IDE1006
        public CancellationToken token => _cts.Token;
        public bool enableHistory => _enableHistory ?? AIDevKitSettings.PromptHistoryOnRuntime;
        public Model model { get => _model; internal set => _model = value; }
        public string sender => _sender;
        public string outputPath => _outputPath;
        public string fileNote => _fileNote;
        public bool saveOutput => _saveOutput;
        public bool ignoreLogs => _ignoreLogs;
        public int n => _n;
        public Dictionary<string, object> options => _options;
        public bool isCanceled => _cts.IsCancellationRequested;
        public virtual MIMEType outputMimeType { get; set; } = MIMEType.Json; // default to JSON
        public virtual bool isWrapperTask => false; // This is not a wrapper task by default

#pragma warning restore IDE1006
        public void Cancel() => _cts.Cancel();

        // HTTP Properties -------------------------------------------------------------------------------------------------------
        internal string _sender;
        internal string _outputPath;
        internal string _fileNote; // Note for the output file, e.g., "Generated by OpenAI GPT-3.5 Turbo"
        internal bool _saveOutput = false;
        internal bool _ignoreLogs = false;

        // AI API Properties ----------------------------------------------------------------------------------------------------- 
        internal Model _model;
        internal int _n = 1; // was called 'outputCount', but 'n' is more familiar to me and matches OpenAI's API.
        private bool? _enableHistory;
        internal Dictionary<string, object> _options; // For Custom Options that exist in other assemblies (e.g., OpenAI, Gemini)

        // Prompt -----------------------------------------------------------------------------------------------------------------
        internal readonly TPrompt prompt;

        protected GENTask() { }
        protected GENTask(TPrompt prompt) => this.prompt = prompt;

        public void SetOption(string key, object value)
        {
            _options ??= new();
            _options[key] = value;
        }

        public bool TryGetOption<T>(string key, out T value)
        {
            if (_options != null && _options.TryGetValue(key, out var obj) && obj is T t)
            {
                value = t;
                return true;
            }

            value = default;
            return false;
        }

        // Fluent API Methods --------------------------------------------------------------------------------------------------

        /// <summary>
        /// Sets the AI model to be used for generation.
        /// </summary>
        public TSelf SetModel(Model model)
        {
            _model = model;
            return this as TSelf;
        }

        /// <summary>
        /// Sets the number of outputs to generate (e.g., number of images or responses).
        /// </summary>
        public TSelf SetCount(int count)
        {
            _n = count;
            return this as TSelf;
        }

        /// <summary>
        /// Sets the download path for the generated content(s).
        /// This is the path where the generated content(s) will be saved.
        /// </summary>
        /// <param name="outputPath">The path where the generated content(s) will be saved.</param>
        public TSelf SetOutputPath(string outputPath, string fileNote = null)
        {
            _outputPath = outputPath;
            _fileNote = fileNote;
            _saveOutput = true; // set saveOutput to true if outputPath is set.
            return this as TSelf;
        }

        /// <summary>
        /// Downloads the generated content(s) to the default path set in the preferences (Tools > Preferences > AI Dev Kit).
        /// </summary>
        public TSelf DownloadOutput()
        {
            _saveOutput = true;
            return this as TSelf;
        }

        /// <summary>
        /// Sets the sender ID for tracking or attribution purposes.
        /// </summary>
        public TSelf SetSender(string sender)
        {
            _sender = sender;
            return this as TSelf;
        }

        public TSelf SetIgnoreLogs(bool ignoreLogs)
        {
            _ignoreLogs = ignoreLogs;
            return this as TSelf;
        }

        public TSelf EnablePromptHistory(bool enableHistory = true)
        {
            _enableHistory = enableHistory;
            return this as TSelf;
        }

        public TSelf SetCancellationToken(CancellationToken token)
        {
            _cts = CancellationTokenSource.CreateLinkedTokenSource(token);
            return this as TSelf;
        }

        // Internal Methods --------------------------------------------------------------------------------------------------
        internal virtual TSelf ResolveOutputPath(Api? api = null, string keyword = null)
        {
            if (!_saveOutput) return this as TSelf;
            api ??= GENTaskUtil.ResolveApi(model);
            keyword ??= GENTaskUtil.ResolveKeyword(model);

            if (GENTaskUtil.TryResolveOutputPath(_saveOutput, _outputPath, outputMimeType, api.Value, keyword, out string path))
            {
                _outputPath = path;
            }
            else
            {
                throw new InvalidOperationException($"Failed to resolve output path for {api}-{keyword}.");
            }

            return this as TSelf;
        }

        // Execution Method -------------------------------------------------------------------------------------------------- 

        /// <summary>
        /// Executes the task and returns the output of type <typeparamref name="TResult"/>.
        /// This is the main entry point for executing the task.
        /// </summary>
        /// <returns></returns>
        public async UniTask<TResult> ExecuteAsync()
        {
            TResult result = await ExecuteAsyncINTERNAL();

            if (result != null && GENTaskUtil.IsCreatingHistory(this))
            {
                SetFileNoteIfNeeded(result);
                if (result is IGeneratedResult generatedResult) PromptRecordFactory.Create(this, generatedResult);
            }

            return result;
        }

        /// <summary>
        /// Allows to set N more than the selected model allows.
        /// This is useful for streaming the responses one by one.
        /// </summary>
        /// <returns></returns>
        public IAsyncEnumerable<TResult> YieldAsync() => YieldAsyncINTERNAL();

        /// <summary>
        /// Interface method to execute the task and return a specific type.
        /// This is useful for tasks that return a specific type of output.
        /// Mainly used internally for <see cref="GENSequence" />.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        /// <exception cref="InvalidOperationException"></exception>
        public async UniTask<T> ExecuteAsync<T>()
        {
            TResult result = await ExecuteAsyncINTERNAL();
            SetFileNoteIfNeeded(result);
            if (result is T t) return t;
            if (result == null && default(T) == null) return default;
            throw new InvalidOperationException($"Invalid output type. Expected {typeof(T)}, but got {typeof(TResult)}.");
        }

        protected abstract UniTask<TResult> ExecuteAsyncINTERNAL();
        protected virtual async IAsyncEnumerable<TResult> YieldAsyncINTERNAL() //=> throw new NotSupportedException($"YieldAsync is not supported for {GetType().Name}. Use ExecuteAsync instead.");
        {
            if (n <= 0) yield break; // No outputs to generate         

            int maxOutput = 1;
            if (model != null) maxOutput = model.MaxN;
            if (maxOutput <= 0) maxOutput = 1;

            int remaining = n;
            List<TResult> results = new();

            while (remaining > 0)
            {
                int batch = Mathf.Min(remaining, maxOutput);

                var taskCopy = MemberwiseClone() as TSelf;
                taskCopy._n = batch;

                var result = await taskCopy.ExecuteAsyncINTERNAL();

                if (result != null)
                {
                    SetFileNoteIfNeeded(result);
                    results.Add(result);
                    yield return result;
                }

                remaining -= batch;
            }

            CreateMergedHistoryRecordINTERNAL(results);
        }

        protected void CreateMergedHistoryRecordINTERNAL(List<TResult> results)
        {
            if (results.IsNotNullOrEmpty())
            {
                AIDevKitDebug.Blue($"Generated {results.Count} results for task {GetType().Name}.");

                if (GENTaskUtil.IsCreatingHistory(this))
                {
                    TResult mergedResult = ResultMerger.Merge(results);
                    PromptRecordFactory.Create(this, mergedResult);
                }
            }
            else
            {
                Debug.LogWarning($"No results generated for task {GetType().Name}. Please check the prompt and model settings.");
            }
        }

        private void SetFileNoteIfNeeded(TResult result)
        {
            if (result is IGeneratedFile file && !string.IsNullOrWhiteSpace(_fileNote))
            {
                file.SetNote(_fileNote);
            }
        }
    }

    /// <summary>
    /// Base class for GENTasks which utilize 
    /// a <see cref="CompletionRequest"/> or 
    /// a <see cref="ChatCompletionRequest"/>.
    /// </summary>
    /// <typeparam name="TSelf"></typeparam> 
    /// <typeparam name="TResult"></typeparam>
    public abstract class GENCompletionTask<TSelf, TResult> : GENTask<TSelf, Prompt, TResult>
        where TSelf : GENCompletionTask<TSelf, TResult>
        where TResult : IGeneratedResult
    {
        internal readonly List<IFile> attachedFiles = new();
        protected GENCompletionTask(Prompt prompt) : base(prompt) { }
        internal string instruction;
        internal string startingMessage;
        internal ModelSettings modelSettings;
        internal ReasoningOptions reasoningOptions;
        internal WebSearchOptions webSearchOptions;
        internal SpeechOutputOptions speechOutputOptions;
        internal ModerationOptions moderationOptions;
        internal List<ToolCall> tools;
        internal List<ChatMessage> messages; // context messages for chat
        internal Func<string, string> textProcessor; // optional text processor for the output
        internal Type jsonSchemaType; // type for JSON schema validation, if needed

        #region Fluent API Methods - Attachments

        public TSelf Attach(params string[] filePaths)
        {
            if (filePaths == null || filePaths.Length == 0) return this as TSelf;

            foreach (var path in filePaths)
            {
                if (string.IsNullOrEmpty(path)) throw new ArgumentException("File path is null or empty.", nameof(filePaths));
                attachedFiles.Add(new RawFile(path));
            }

            return this as TSelf;
        }

        public TSelf Attach(params FileInfo[] fileInfos)
        {
            if (fileInfos == null || fileInfos.Length == 0) return this as TSelf;

            foreach (var fileInfo in fileInfos)
            {
                if (fileInfo == null) throw new ArgumentNullException(nameof(fileInfos), "One of the FileInfo entries is null.");
                if (!fileInfo.Exists) throw new FileNotFoundException("File not found.", fileInfo.FullName);
                attachedFiles.Add(new RawFile(fileInfo));
            }

            return this as TSelf;
        }

        public TSelf Attach(params Texture2D[] textures)
        {
            if (textures == null || textures.Length == 0) return this as TSelf;

            foreach (var texture in textures)
            {
                if (texture == null) throw new ArgumentNullException(nameof(textures), "One of the Texture2D entries is null.");
                attachedFiles.Add(new File<Texture2D>(texture));
            }

            return this as TSelf;
        }

        public TSelf Attach(params AudioClip[] audioClips)
        {
            if (audioClips == null || audioClips.Length == 0) return this as TSelf;

            foreach (var audioClip in audioClips)
            {
                if (audioClip == null) throw new ArgumentNullException(nameof(audioClips), "One of the AudioClip entries is null.");
                attachedFiles.Add(new File<AudioClip>(audioClip));
            }

            return this as TSelf;
        }

        public TSelf Attach(params IFile[] files)
        {
            if (files == null || files.Length == 0) return this as TSelf;

            foreach (var file in files)
            {
                if (file == null) throw new ArgumentNullException(nameof(files), "One of the IRawFile entries is null.");
                attachedFiles.Add(file);
            }

            return this as TSelf;
        }

        #endregion


        /// <summary>
        /// Sets the instruction for the task. This is a specific command or request for the model to follow.
        /// </summary>
        /// <param name="instruction"></param>
        /// <returns></returns>
        public TSelf SetInstruction(string instruction)
        {
            this.instruction = instruction;
            return this as TSelf;
        }

        public TSelf SetStartingMessage(string startingMessage)
        {
            this.startingMessage = startingMessage;
            return this as TSelf;
        }

        /// <summary>
        /// Sets the generation options for the task.
        /// </summary>
        public TSelf SetModelSettings(ModelSettings settings)
        {
            if (settings == null) return this as TSelf;
            modelSettings = settings;
            return this as TSelf;
        }

        public TSelf SetReasoning(ReasoningEffort effort)
        {
            if (effort == ReasoningEffort.Medium) return this as TSelf;
            reasoningOptions ??= new ReasoningOptions();
            reasoningOptions.Effort = effort;
            return this as TSelf;
        }

        public TSelf SetReasoning(ReasoningOptions options)
        {
            if (options == null) return this as TSelf;
            reasoningOptions = options;
            return this as TSelf;
        }

        public TSelf SetSpeechOutput(SpeechOutputOptions options = null)
        {
            speechOutputOptions = options ?? new SpeechOutputOptions();
            return this as TSelf;
        }

        public TSelf SetWebSearchOptions(WebSearchOptions webSearchOptions)
        {
            if (webSearchOptions == null) return this as TSelf;
            this.webSearchOptions = webSearchOptions;
            return this as TSelf;
        }

        public TSelf SetModeration(ModerationOptions options)
        {
            if (options == null) return this as TSelf;
            moderationOptions = options;
            return this as TSelf;
        }

        public TSelf SetTools(params ToolCall[] tools)
        {
            if (tools == null || tools.Length == 0) return this as TSelf;
            this.tools = tools.ToList();
            return this as TSelf;
        }

        public TSelf AddTools(params ToolCall[] tools)
        {
            if (tools == null || tools.Length == 0) return this as TSelf;
            this.tools ??= new List<ToolCall>();
            this.tools.AddRange(tools);
            return this as TSelf;
        }

        public TSelf SetFunctions(params FunctionCall[] functions)
        {
            if (functions == null || functions.Length == 0) return this as TSelf;
            tools = functions.ToList().ConvertAll(f => f as ToolCall);
            return this as TSelf;
        }

        public TSelf AddFunctions(params FunctionCall[] functions)
        {
            if (functions == null || functions.Length == 0) return this as TSelf;
            tools ??= new List<ToolCall>();
            tools.AddRange(functions.ToList().ConvertAll(f => f as ToolCall));
            return this as TSelf;
        }

        public TSelf SetMessages(params ChatMessage[] messages)
        {
            if (messages == null || messages.Length == 0) return this as TSelf;
            this.messages = messages.ToList();
            return this as TSelf;
        }

        public TSelf AddMessages(params ChatMessage[] messages)
        {
            if (messages == null || messages.Length == 0) return this as TSelf;
            this.messages ??= new List<ChatMessage>();
            this.messages.AddRange(messages);
            return this as TSelf;
        }

        public TSelf SetJsonSchema(Type jsonSchemaType)
        {
            this.jsonSchemaType = jsonSchemaType;
            return this as TSelf;
        }
    }

    /// <summary>
    /// Task for generating text using an LLM model. Supports instructions and role-based prompts.
    /// </summary>
    public class GENResponseTask : GENCompletionTask<GENResponseTask, ChatCompletion>
    {
        private ChatCompletionStreamHandlerBuilder streamHandlerBuilder;
        public GENResponseTask(Prompt prompt) : base(prompt) { }

        // Execution Method --------------------------------------------------------------------------------------------------

        #region Fluent API Methods - Stream Events

        public GENResponseTask OnStreamText(Action<string> onReceiveText, Action<string> onReceiveRefusal = null)
        {
            streamHandlerBuilder ??= new();
            streamHandlerBuilder.SetOnReceiveText(onReceiveText);
            streamHandlerBuilder.SetOnReceiveRefusal(onReceiveRefusal);
            return this;
        }

        public GENResponseTask OnStreamToolCalls(Action<ToolCall[]> onToolCalls)
        {
            streamHandlerBuilder ??= new();
            streamHandlerBuilder.SetOnReceiveToolCalls(onToolCalls);
            return this;
        }

        public GENResponseTask OnStreamDeltaChunk(Action<ChatDelta[]> onDeltaChunk)
        {
            streamHandlerBuilder ??= new();
            streamHandlerBuilder.SetOnReceiveDeltaChunk(onDeltaChunk);
            return this;
        }

        public GENResponseTask OnStreamError(Action<string> onError)
        {
            streamHandlerBuilder ??= new();
            streamHandlerBuilder.SetOnError(onError);
            return this;
        }

        public GENResponseTask OnStreamDone(Action<ChatCompletion> onDone)
        {
            streamHandlerBuilder ??= new();
            streamHandlerBuilder.SetOnDone(onDone);
            return this;
        }

        protected IChatCompletionStreamHandler ResolveStreamHandler(IChatCompletionStreamHandler streamHandler)
        {
            if (streamHandler != null) return streamHandler.SetTask(this);
            if (streamHandlerBuilder == null)
                throw new ArgumentNullException(nameof(streamHandlerBuilder), "Stream handler builder is null. Use OnStreamText, OnStreamToolCalls, OnStreamError, or OnStreamDone to set the stream handler.");
            streamHandler = streamHandlerBuilder.Build();
            streamHandler.SetTask(this);
            return streamHandler;
        }

        #endregion

        /// <summary>
        /// Executes the text generation and returns the full response as a string.
        /// </summary>
        protected override async UniTask<ChatCompletion> ExecuteAsyncINTERNAL() => await GENTaskManager.GenerateContentAsync(this, jsonSchemaType);

        /// <summary>
        /// Streams text generation output in real time as it's received from the model.
        /// </summary> 
        public UniTask StreamAsync(IChatCompletionStreamHandler streamHandler = null) => GENTaskManager.StreamContentAsync(this, jsonSchemaType, ResolveStreamHandler(streamHandler));
    }

    /// <summary> 
    /// Task for generating structured output (e.g., JSON) using an LLM model.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class GENStructTask<T> : GENCompletionTask<GENStructTask<T>, StructuredOutput<T>> where T : class
    {
        public override bool isWrapperTask => true;
        public GENStructTask(string prompt) : base(prompt) { }

        // Execution Method --------------------------------------------------------------------------------------------------
        protected override async UniTask<StructuredOutput<T>> ExecuteAsyncINTERNAL()
        {
            GENResponseTask contentTask = new(prompt)
            {
                _model = model,
                _n = n,
                _outputPath = _outputPath,
                _sender = sender,
                instruction = instruction,
            };

            ChatCompletion response = await GENTaskManager.GenerateContentAsync(contentTask, typeof(T));
            string[] jsons = response.ToStringArray();
            if (jsons == null || jsons.Length == 0) throw new InvalidOperationException("Failed to generate content.");

            T[] values = new T[jsons.Length];
            for (int i = 0; i < jsons.Length; i++)
            {
                if (string.IsNullOrEmpty(jsons[i])) continue;
                values[i] = JsonConvert.DeserializeObject<T>(jsons[i]);
            }

            return new StructuredOutput<T>(values, response.GetToolCalls(), response.Usage);
        }
    }

    /// <summary>
    /// Added new on 2025.05.28
    /// Task for generating code snippets or scripts for Unity C#.
    /// </summary>
    public class GENCodeTask : GENCompletionTask<GENCodeTask, GeneratedText>
    {
        public override bool isWrapperTask => true;
        protected static readonly string[] _toRemove = { "```csharp", "```", };
        public GENCodeTask(Prompt prompt) : base(prompt) { }

        // Execution Method --------------------------------------------------------------------------------------------------

        private string ParseCode(string resultText)
        {
            if (string.IsNullOrWhiteSpace(resultText)) return null;

            foreach (string item in _toRemove)
            {
                resultText = resultText.Replace(item, string.Empty);
            }

            resultText = resultText.Trim();

            // if it doesn't start with 'using', find the first 'using' and remove everything before it
            if (!resultText.StartsWith("using", StringComparison.Ordinal))
            {
                int index = resultText.IndexOf("using", StringComparison.Ordinal);
                if (index > 0) resultText = resultText.Substring(index);
            }

            // if it doesn't end with '}', find the last '}' and remove everything after it
            if (!resultText.EndsWith("}"))
            {
                int index = resultText.LastIndexOf("}", StringComparison.Ordinal);
                if (index > 0) resultText = resultText.Substring(0, index + 1);
            }

            return resultText.Trim();
        }

        protected override async UniTask<GeneratedText> ExecuteAsyncINTERNAL()
        {
            GENResponseTask codeTask = new(prompt)
            {
                _model = model,
                instruction = string.IsNullOrWhiteSpace(instruction) ? AIDevKitConfig.CodeGenInstruction : instruction,
                _n = n,
                _outputPath = _outputPath,
                _sender = sender,
                textProcessor = ParseCode,
            };

            ChatCompletion chatCompletion = await codeTask.ExecuteAsync();

            return new GeneratedText(
                chatCompletion.ToStringArray(),
                chatCompletion.Usage
            );
        }
    }

    /// <summary>
    /// Task for generating image(s) from text using supported models (e.g., OpenAI DALL·E, Google Imagen).
    /// </summary>
    public class GENImageTask : GENTask<GENImageTask, Prompt, GeneratedImage>
    {
        public override MIMEType outputMimeType { get; set; } = MIMEType.PNG;
        public GENImageTask(Prompt prompt) : base(prompt) { }
        protected override UniTask<GeneratedImage> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateImageAsync(this);
    }

    /// <summary>
    /// Task for editing an existing image based on a text prompt and optional mask (OpenAI or Google Gemini).
    /// </summary>
    public class GENInpaintTask : GENTask<GENInpaintTask, InpaintPrompt, GeneratedImage>
    {
        public override MIMEType outputMimeType { get; set; } = MIMEType.PNG;
        public GENInpaintTask(InpaintPrompt prompt) : base(prompt) { }
        protected override UniTask<GeneratedImage> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateImageEditAsync(this);
    }

    // <summary>
    // Legacy API. Only works with DALL·E 2.
    // </summary>
    // public class GENImageVariationTask : GENTask<GENImageVariationTask, Texture2D, GeneratedImage>
    // {
    //     public override MIMEType outputMimeType { get; set; } = MIMEType.PNG;
    //     public GENImageVariationTask(Texture2D promptImage) : base(promptImage) { }
    //     protected override UniTask<GeneratedImage> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateImageVariationAsync(this);
    // }

    public abstract class GENAudioOutputTask<TSelf, TPrompt> : GENTask<TSelf, TPrompt, GeneratedAudio>, IGENTask
       where TSelf : GENAudioOutputTask<TSelf, TPrompt>
    {
        public override MIMEType outputMimeType { get; set; } = MIMEType.MPEG; // default to MP3   
        protected GENAudioOutputTask(TPrompt prompt) : base(prompt) { }
        public GENSpeechTask SetEncoding(AudioEncoding encoding)
        {
            outputMimeType = encoding.ToMIMEType();
            return this as GENSpeechTask;
        }
    }

    public abstract class GENAudioInputTask<TSelf, TResult> : GENTask<TSelf, AudioClip, TResult>, IGENTask
        where TSelf : GENAudioInputTask<TSelf, TResult>
        where TResult : IGeneratedResult
    {
        protected GENAudioInputTask(AudioClip prompt) : base(prompt) { }
    }

    /// <summary>
    /// Task for generating synthetic speech (text-to-speech) using the specified model.
    /// </summary>
    public class GENSpeechTask : GENAudioOutputTask<GENSpeechTask, string>
    {
        public override MIMEType outputMimeType { get; set; } = MIMEType.MPEG; // default to MP3    
        public GENSpeechTask(string prompt) : base(prompt) { }

        internal Voice voice;
        internal float? speed;
        internal uint? seed; // not available on OpenAI 

        // Fluent API Methods -------------------------------------------------------------------------------------------------- 
        /// <summary>
        /// Sets the voice preset name (string-based, for future compatibility).
        /// </summary>
        public GENSpeechTask SetVoice(Voice voice)
        {
            this.voice = voice;
            return this;
        }

        /// <summary>
        /// Sets the playback speed of the synthesized voice.
        /// </summary>
        public GENSpeechTask SetSpeed(float speed)
        {
            this.speed = speed;
            return this;
        }

        /// <summary>
        /// Sets a fixed seed to make generation deterministic and repeatable.
        /// </summary>
        public GENSpeechTask SetSeed(uint seed)
        {
            this.seed = seed;
            return this;
        }


        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<GeneratedAudio> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateSpeechAsync(this);
        public UniTask StreamAsync(RealtimeAudioPlayer streamAudioPlayer) => GENTaskManager.StreamSpeechAsync(this, streamAudioPlayer);
    }

    /// <summary>
    /// Task for converting speech audio into text (speech-to-text).
    /// </summary>
    public class GENTranscriptTask : GENAudioInputTask<GENTranscriptTask, Transcript>
    {
        // --- OpenAI only ---
        internal SystemLanguage? language;
        public GENTranscriptTask(AudioClip prompt) : base(prompt) { }

        // Fluent API Methods -------------------------------------------------------------------------------------------------- 

        /// <summary>
        /// Optionally sets the language hint to improve transcription accuracy.
        /// </summary>
        public GENTranscriptTask SetLanguage(SystemLanguage language)
        {
            this.language = language;
            return this;
        }

        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<Transcript> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateTranscriptAsync(this);
    }

    /// <summary>
    /// Task for translating speech into English text using the speech translation model.
    /// </summary>
    public class GENTranslationTask : GENAudioInputTask<GENTranslationTask, GeneratedText>
    {
        public GENTranslationTask(AudioClip prompt) : base(prompt) { }

        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<GeneratedText> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateTranslationAsync(this);
    }

    /// <summary>
    /// Task for generating sound effects based on a text prompt.
    /// </summary>
    public class GENSoundEffectTask : GENAudioOutputTask<GENSoundEffectTask, string>
    {
        // --- ElevenLabs only ---        
        internal double? durationSeconds;
        internal double? promptInfluence;
        public GENSoundEffectTask(string prompt) : base(prompt) { }

        // Fluent API Methods --------------------------------------------------------------------------------------------------

        /// <summary>
        /// Sets the duration of the generated sound effect in seconds.
        /// </summary>
        public GENSoundEffectTask SetDuration(double durationSeconds)
        {
            this.durationSeconds = durationSeconds;
            return this;
        }

        /// <summary>
        /// Sets the influence of the prompt on the generated sound effect.
        /// </summary>
        /// <param name="promptInfluence">Value between 0 and 1.</param> 
        public GENSoundEffectTask SetPromptInfluence(double promptInfluence)
        {
            this.promptInfluence = promptInfluence;
            return this;
        }

        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<GeneratedAudio> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateSoundEffectAsync(this);
    }

    public class GENVoiceChangeTask : GENAudioOutputTask<GENVoiceChangeTask, AudioClip>
    {
        // --- ElevenLabs only ---
        internal Voice voice;
        internal uint? seed;
        internal bool? removeBackgroundNoise;
        public GENVoiceChangeTask(AudioClip prompt) : base(prompt) { }

        // Fluent API Methods --------------------------------------------------------------------------------------------------

        public GENVoiceChangeTask SetVoice(Voice voice)
        {
            this.voice = voice;
            return this;
        }

        /// <summary>
        /// Sets a fixed seed to make generation deterministic and repeatable.
        /// </summary>
        public GENVoiceChangeTask SetSeed(uint seed)
        {
            this.seed = seed;
            return this;
        }

        /// <summary>
        /// Sets whether to remove background noise from the input audio.
        /// </summary>
        public GENVoiceChangeTask RemoveBackgroundNoise(bool removeBackgroundNoise)
        {
            this.removeBackgroundNoise = removeBackgroundNoise;
            return this;
        }

        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<GeneratedAudio> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateVoiceChangeAsync(this);
    }

    public class GENAudioIsolationTask : GENAudioOutputTask<GENAudioIsolationTask, AudioClip>
    {
        public GENAudioIsolationTask(AudioClip prompt) : base(prompt) { }

        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<GeneratedAudio> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateAudioIsolationAsync(this);
    }

    public class GENVideoTask : GENTask<GENVideoTask, Prompt, GeneratedVideo>
    {
        public override MIMEType outputMimeType { get; set; } = MIMEType.MP4; // default to MP4
        internal readonly Texture2D promptImage; // input image for chat, image edit
        public GENVideoTask(Prompt promptText) : base(promptText) { }
        public GENVideoTask(Texture2D promptImage) : base(null) => this.promptImage = promptImage;

        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<GeneratedVideo> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateVideoAsync(this);
    }

    /// <summary>
    /// Audio not supported yet.
    /// </summary>
    public class GENModerationTask : GENTask<GENModerationTask, string, Moderation>
    {
        internal readonly List<IFile> attachedFiles = new();
        internal readonly List<SafetySetting> safetySettings;

        public GENModerationTask(string prompt, IEnumerable<SafetySetting> safetySettings) : base(prompt)
        {
            if (safetySettings.IsNullOrEmpty()) throw new ArgumentNullException(nameof(safetySettings), "Safety settings are null or empty.");
            this.safetySettings = new List<SafetySetting>(safetySettings);
        }

        // Fluent API Methods --------------------------------------------------------------------------------------------------
        public GENModerationTask AddSafetySetting(SafetySetting safetySetting)
        {
            if (safetySetting == null) throw new ArgumentNullException(nameof(safetySetting), "Safety setting is null.");

            // check if the category already exists
            if (safetySettings.IsNullOrEmpty())
            {
                safetySettings.Add(safetySetting);
                return this;
            }

            foreach (var setting in safetySettings)
            {
                if (setting.Category == safetySetting.Category)
                {
                    setting.Threshold = safetySetting.Threshold;
                    return this;
                }
            }

            // if not, add the new setting
            safetySettings.Add(safetySetting);
            return this;
        }

        public GENModerationTask RemoveSafetySetting(HarmCategory category)
        {
            if (safetySettings.IsNullOrEmpty()) return this;
            safetySettings.RemoveAll(setting => setting.Category == category);
            return this;
        }


        public GENModerationTask Attach(params string[] filePaths)
        {
            if (filePaths == null || filePaths.Length == 0)
                throw new ArgumentNullException(nameof(filePaths), "File paths array is null or empty.");

            foreach (var path in filePaths)
            {
                if (string.IsNullOrEmpty(path)) throw new ArgumentException("File path is null or empty.", nameof(filePaths));
                attachedFiles.Add(new RawFile(path));
            }

            return this;
        }

        public GENModerationTask Attach(params FileInfo[] fileInfos)
        {
            if (fileInfos == null || fileInfos.Length == 0)
                throw new ArgumentNullException(nameof(fileInfos), "FileInfo array is null or empty.");

            foreach (var fileInfo in fileInfos)
            {
                if (fileInfo == null) throw new ArgumentNullException(nameof(fileInfos), "One of the FileInfo entries is null.");
                if (!fileInfo.Exists) throw new FileNotFoundException("File not found.", fileInfo.FullName);
                attachedFiles.Add(new RawFile(fileInfo));
            }

            return this;
        }

        public GENModerationTask Attach(params Texture2D[] textures)
        {
            if (textures == null || textures.Length == 0)
                throw new ArgumentNullException(nameof(textures), "Texture2D array is null or empty.");

            foreach (var texture in textures)
            {
                if (texture == null) throw new ArgumentNullException(nameof(textures), "One of the Texture2D entries is null.");
                attachedFiles.Add(new File<Texture2D>(texture));
            }

            return this;
        }

        public GENModerationTask Attach(params AudioClip[] audioClips)
        {
            if (audioClips == null || audioClips.Length == 0)
                throw new ArgumentNullException(nameof(audioClips), "AudioClip array is null or empty.");

            foreach (var audioClip in audioClips)
            {
                if (audioClip == null) throw new ArgumentNullException(nameof(audioClips), "One of the AudioClip entries is null.");
                attachedFiles.Add(new File<AudioClip>(audioClip));
            }

            return this;
        }

        public GENModerationTask Attach(params IFile[] files)
        {
            if (files == null || files.Length == 0)
                throw new ArgumentNullException(nameof(files), "File array is null or empty.");

            foreach (var file in files)
            {
                if (file == null) throw new ArgumentNullException(nameof(files), "One of the IRawFile entries is null.");
                attachedFiles.Add(file);
            }

            return this;
        }


        // Execution Method -------------------------------------------------------------------------------------------------- 
        protected override UniTask<Moderation> ExecuteAsyncINTERNAL() => GENTaskManager.GenerateModerationAsync(this);
    }
}