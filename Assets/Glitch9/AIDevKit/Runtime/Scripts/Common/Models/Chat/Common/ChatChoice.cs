using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Glitch9.AIDevKit
{
    public class ChatChoice
    {
        /// <summary>
        /// The index of the choice in the list of choices.
        /// </summary>
        [JsonProperty("index")] public int Index { get; set; }

        /// <summary>
        /// A chat completion message generated by the model.
        /// </summary>
        [JsonProperty("message")] public ChatMessage Message { get; set; }

        /// <summary>
        /// A streaming chat completion message generated by the model.
        /// </summary>
        [JsonProperty("delta")] public ChatDelta Delta { get; set; }

        /// <summary>
        /// Only used for legacy model requests.
        /// </summary>
        [JsonProperty("text")] public string Text { get; set; }

        /// <summary>
        /// Log probability information for the choice.
        /// </summary>
        [JsonProperty("logprobs")] public Logprobs Logprobs { get; set; }

        /// <summary>
        /// The reason the model stopped generating tokens. 
        /// This will be stopped if the model hit a natural stop point or a provided stop sequence, 
        /// length if the maximum number of tokens specified in the request was reached, 
        /// content_filter if content was omitted due to a flag from our content filters, 
        /// or function_call if the model called a Function.
        /// </summary>
        [JsonProperty("finish_reason")] public StopReason? FinishReason { get; set; }
    }

    public class ChatDelta
    {
        public static implicit operator string(ChatDelta delta) => delta?.Content ?? string.Empty;

        /// <summary>
        /// The contents of the chunk message.
        /// </summary>
        [JsonProperty("content")] public string Content { get; set; }

        /// <summary>
        /// The refusal message generated by the model.
        /// </summary>
        [JsonProperty("refusal")] public string Refusal { get; set; }

        /// <summary>
        /// The role of the author of this message.
        /// </summary>
        [JsonProperty("role")] public ChatRole Role { get; set; }

        /// <summary>
        /// The name and arguments of a function that should be called, as generated by the model.
        /// /// </summary>
        [JsonProperty("tool_calls")] public ToolCall[] ToolCalls { get; set; }

        public string FirstTextDelta() => Content;
    }

    /// <summary>
    /// Log probability information for the choice.
    /// </summary>
    public class Logprobs
    {
        /// <summary>
        /// A list of message content tokens with log probability information.
        /// </summary>
        [JsonProperty("content")] public LogprobsContent[] Content { get; set; }

        /// <summary>
        /// A list of message refusal tokens with log probability information.
        /// </summary>
        [JsonProperty("refusal")] public LogprobsContent[] Refusal { get; set; }
    }

    /// <summary>
    /// A list of message content tokens with log probability information.
    /// </summary>
    public class LogprobsContent
    {
        /// <summary>
        /// The token.
        /// </summary>
        [JsonProperty("token")] public string Token { get; set; }

        /// <summary>
        /// The log probability of this token, if it is within the top 20 most likely tokens.
        /// Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
        /// </summary>
        [JsonProperty("logprob")] public double? Logprob { get; set; }

        /// <summary>
        /// A list of integers representing the UTF-8 bytes representation of the token.
        /// Useful in instances where characters are represented by multiple tokens
        /// and their byte representations must be combined to generate the correct text representation.
        /// Can be null if there is no bytes representation for the token.
        /// </summary>
        [JsonProperty("bytes")] public int[] Bytes { get; set; }

        /// <summary>
        /// List of the most likely tokens and their log probability, at this token position.
        /// In rare cases, there may be fewer than the number of requested top_logprobs returned.
        /// </summary>
        [JsonProperty("top_logprobs")] public LogprobsContent[] TopLogprobs { get; set; }
    }

    internal static class ChatChoiceArrayExtensions
    {
        internal static string GetFirstMessageText(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return string.Empty;

            foreach (var choice in choices)
            {
                var message = choice.Message;

                if (message != null && !string.IsNullOrEmpty(message))
                {
                    return message;
                }
            }

            return string.Empty;
        }

        internal static Content[] GetContents(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return null;

            List<Content> contents = new();

            foreach (var choice in choices)
            {
                var message = choice?.Message;

                if (message != null && message.Content != null)
                {
                    contents.Add(message.Content);
                }
            }

            return contents.ToArray();
        }

        internal static ToolCall[] GetToolCalls(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return null;

            foreach (var choice in choices)
            {
                var message = choice?.Message;

                if (message is ResponseMessage assistantMessage)
                {
                    var toolCalls = assistantMessage.Tools;

                    if (toolCalls != null && toolCalls.Length > 0)
                    {
                        return toolCalls;
                    }
                }
            }

            return null;
        }

        internal static Content GetFirstContent(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return null;

            foreach (var choice in choices)
            {
                var content = choice?.Message?.Content;

                if (content != null) return content;
            }

            return null;
        }

        internal static ChatDelta GetFirstDelta(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return null;

            foreach (var choice in choices)
            {
                var delta = choice.Delta;

                if (delta != null) return delta;
            }

            return null;
        }

        internal static string GetFirstDeltaText(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return string.Empty;

            foreach (var choice in choices)
            {
                var delta = choice.Delta;

                if (delta != null && !string.IsNullOrEmpty(delta))
                {
                    return delta;
                }
            }

            return string.Empty;
        }

        internal static ChatMessage GetFirstMessage(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return null;

            foreach (var choice in choices)
            {
                var message = choice?.Message;

                if (message != null) return message;
            }

            return null;
        }

        internal static ResponseMessage GetFirstResponseMessage(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return null;

            foreach (var choice in choices)
            {
                if (choice?.Message is ResponseMessage message)
                {
                    return message;
                }
            }

            return null;
        }

        internal static ResponseMessage[] GetResponseMessages(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty()) return null;

            List<ResponseMessage> messages = new();

            foreach (var choice in choices)
            {
                if (choice?.Message is ResponseMessage message)
                {
                    messages.Add(message);
                }
            }

            return messages.ToArray();
        }

        internal static string[] GetStringArray(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty())
            {
                Debug.LogWarning("ChatChoice array is null or empty.");
                return null;
            }

            List<string> strings = new();

            foreach (var choice in choices)
            {
                var message = choice?.Message;

                if (message != null && !string.IsNullOrEmpty(message))
                {
                    strings.Add(message);
                }
            }

            return strings.ToArray();
        }

        internal static ChatDelta[] GetDeltaChunks(this ChatChoice[] choices)
        {
            if (choices.IsNullOrEmpty())
            {
                Debug.LogWarning("ChatChoice array is null or empty.");
                return null;
            }

            List<ChatDelta> deltas = new();

            foreach (var choice in choices)
            {
                var delta = choice?.Delta;

                if (delta != null)
                {
                    deltas.Add(delta);
                }
            }

            return deltas.ToArray();
        }
    }
}
